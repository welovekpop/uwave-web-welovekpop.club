{"version":3,"sources":["actions/TickerActionCreators.js"],"names":["syncTimestamps","sync","createTimer","stopTimer","clientTimeBefore","serverTime","clientTimeAfter","Date","now","type","payload","Math","round","before","onComplete","time","cb","dispatch","last","syncing","finishedSync","intv","setInterval","abs","then","getState","timer","clearInterval"],"mappings":";;;;;QAKgBA,c,GAAAA,c;QAQAC,I,GAAAA,I;QAeAC,W,GAAAA,W;QAgCAC,S,GAAAA,S;;AA5DhB;;AAEA;;AACA;;AAEO,SAASH,cAAT,CAAwBI,gBAAxB,EAA0CC,UAA1C,EAAsD;AAC3D,MAAIC,kBAAkBC,KAAKC,GAAL,EAAtB;AACA,SAAO;AACLC,sBADK;AAELC,aAASC,KAAKC,KAAL,CAAW,CAACP,aAAaD,gBAAb,IAAiCC,aAAaC,eAA9C,CAAD,IAAmE,CAA9E;AAFJ,GAAP;AAID;;AAEM,SAASL,IAAT,GAAgB;AACrB,MAAIY,SAASN,KAAKC,GAAL,EAAb;AACA,SAAO,gCAAI,MAAJ,EAAY;AACjBM,gBAAY,SAASA,UAAT,CAAoBN,GAApB,EAAyB;AACnC,aAAOR,eAAea,MAAf,EAAuBL,IAAIO,IAA3B,CAAP;AACD;AAHgB,GAAZ,CAAP;AAKD;;AAED;;;;;;AAMO,SAASb,WAAT,CAAqBc,EAArB,EAAyB;AAC9B,SAAO,UAAUC,QAAV,EAAoB;AACzB,QAAIC,OAAOX,KAAKC,GAAL,EAAX;AACA,QAAIW,UAAU,KAAd;;AAEA,aAASC,YAAT,GAAwB;AACtBD,gBAAU,KAAV;AACAH;AACD;;AAED,QAAIK,OAAOC,YAAY,YAAY;AACjC;AACA;AACA,UAAId,MAAMD,KAAKC,GAAL,EAAV;AACA,UAAIG,KAAKY,GAAL,CAASL,OAAOV,GAAhB,IAAuB,IAA3B,EAAiC;AAC/BW,kBAAU,IAAV;AACAF,iBAAShB,MAAT,EAAiBuB,IAAjB,CAAsBJ,YAAtB,EAAoCA,YAApC;AACD,OAHD,MAGO,IAAI,CAACD,OAAL,EAAc;AACnB;AACA;AACAH;AACD;AACDE,aAAOV,GAAP;AACD,KAbU,EAaR,IAbQ,CAAX;;AAeAS,aAAS;AACPR,2BADO;AAEPC,eAASW;AAFF,KAAT;AAID,GA5BD;AA6BD;;AAEM,SAASlB,SAAT,GAAqB;AAC1B,SAAO,UAAUc,QAAV,EAAoBQ,QAApB,EAA8B;AACnC,QAAIC,QAAQ,kCAAcD,UAAd,CAAZ;AACAE,kBAAcD,KAAd;AACAT,aAAS;AACPR,2BADO;AAEPC,eAAS;AAFF,KAAT;AAID,GAPD;AAQD;AACD","file":"TickerActionCreators.js","sourcesContent":["import { get } from './RequestActionCreators';\n\nimport { SET_TIMER, OFFSET } from '../constants/actionTypes/time';\nimport { timerSelector } from '../selectors/timeSelectors';\n\nexport function syncTimestamps(clientTimeBefore, serverTime) {\n  const clientTimeAfter = Date.now();\n  return {\n    type: OFFSET,\n    payload: Math.round(((serverTime - clientTimeBefore) + (serverTime - clientTimeAfter)) / 2),\n  };\n}\n\nexport function sync() {\n  const before = Date.now();\n  return get('/now', {\n    onComplete: now => syncTimestamps(before, now.time),\n  });\n}\n\n/**\n * Create an auto-syncing timer that ticks once each second.\n *\n * When dispatched, the action returns an array. Functions pushed\n * to this array will be called on each tick.\n */\nexport function createTimer(cb) {\n  return (dispatch) => {\n    let last = Date.now();\n    let syncing = false;\n\n    function finishedSync() {\n      syncing = false;\n      cb();\n    }\n\n    const intv = setInterval(() => {\n      // Resync if one 1000ms interval skipped over more than 5s of time.\n      // This most likely means the user's computer's time changed.\n      const now = Date.now();\n      if (Math.abs(last - now) > 5000) {\n        syncing = true;\n        dispatch(sync()).then(finishedSync, finishedSync);\n      } else if (!syncing) {\n        // If we're currently syncing we don't update timed elements for\n        // a while, to prevent weird back and forth jumps.\n        cb();\n      }\n      last = now;\n    }, 1000);\n\n    dispatch({\n      type: SET_TIMER,\n      payload: intv,\n    });\n  };\n}\n\nexport function stopTimer() {\n  return (dispatch, getState) => {\n    const timer = timerSelector(getState());\n    clearInterval(timer);\n    dispatch({\n      type: SET_TIMER,\n      payload: null,\n    });\n  };\n}\n"]}