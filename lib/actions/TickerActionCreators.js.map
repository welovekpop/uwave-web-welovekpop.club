{"version":3,"sources":["actions/TickerActionCreators.js"],"names":["syncTimestamps","clientTimeBefore","serverTime","clientTimeAfter","Date","now","type","OFFSET","payload","Math","round","sync","before","onComplete","time","createTimer","cb","dispatch","last","syncing","finishedSync","intv","setInterval","abs","then","SET_TIMER","stopTimer","getState","timer","clearInterval"],"mappings":";;;;;;;;;;AAAA;;AACA;;AACA;;AACO,SAASA,cAAT,CAAwBC,gBAAxB,EAA0CC,UAA1C,EAAsD;AAC3D,MAAIC,kBAAkBC,KAAKC,GAAL,EAAtB;AACA,SAAO;AACLC,UAAMC,mBADD;AAELC,aAASC,KAAKC,KAAL,CAAW,CAACR,aAAaD,gBAAb,IAAiCC,aAAaC,eAA9C,CAAD,IAAmE,CAA9E;AAFJ,GAAP;AAID;;AACM,SAASQ,IAAT,GAAgB;AACrB,MAAIC,SAASR,KAAKC,GAAL,EAAb;AACA,SAAO,gCAAI,MAAJ,EAAY;AACjBQ,gBAAY,SAASA,UAAT,CAAoBR,GAApB,EAAyB;AACnC,aAAOL,eAAeY,MAAf,EAAuBP,IAAIS,IAA3B,CAAP;AACD;AAHgB,GAAZ,CAAP;AAKD;AACD;;;;;;;;AAOO,SAASC,WAAT,CAAqBC,EAArB,EAAyB;AAC9B,SAAO,UAAUC,QAAV,EAAoB;AACzB,QAAIC,OAAOd,KAAKC,GAAL,EAAX;AACA,QAAIc,UAAU,KAAd;;AAEA,aAASC,YAAT,GAAwB;AACtBD,gBAAU,KAAV;AACAH;AACD;;AAED,QAAIK,OAAOC,YAAY,YAAY;AACjC;AACA;AACA,UAAIjB,MAAMD,KAAKC,GAAL,EAAV;;AAEA,UAAII,KAAKc,GAAL,CAASL,OAAOb,GAAhB,IAAuB,IAA3B,EAAiC;AAC/Bc,kBAAU,IAAV;AACAF,iBAASN,MAAT,EAAiBa,IAAjB,CAAsBJ,YAAtB,EAAoCA,YAApC;AACD,OAHD,MAGO,IAAI,CAACD,OAAL,EAAc;AACnB;AACA;AACAH;AACD;;AAEDE,aAAOb,GAAP;AACD,KAfU,EAeR,IAfQ,CAAX;AAgBAY,aAAS;AACPX,YAAMmB,sBADC;AAEPjB,eAASa;AAFF,KAAT;AAID,GA7BD;AA8BD;;AACM,SAASK,SAAT,GAAqB;AAC1B,SAAO,UAAUT,QAAV,EAAoBU,QAApB,EAA8B;AACnC,QAAIC,QAAQ,kCAAcD,UAAd,CAAZ;AACAE,kBAAcD,KAAd;AACAX,aAAS;AACPX,YAAMmB,sBADC;AAEPjB,eAAS;AAFF,KAAT;AAID,GAPD;AAQD","file":"TickerActionCreators.js","sourcesContent":["import { get } from './RequestActionCreators';\nimport { SET_TIMER, OFFSET } from '../constants/ActionTypes';\nimport { timerSelector } from '../selectors/timeSelectors';\n\nexport function syncTimestamps(clientTimeBefore, serverTime) {\n  const clientTimeAfter = Date.now();\n  return {\n    type: OFFSET,\n    payload: Math.round(((serverTime - clientTimeBefore) + (serverTime - clientTimeAfter)) / 2),\n  };\n}\n\nexport function sync() {\n  const before = Date.now();\n  return get('/now', {\n    onComplete: now => syncTimestamps(before, now.time),\n  });\n}\n\n/**\n * Create an auto-syncing timer that ticks once each second.\n *\n * When dispatched, the action returns an array. Functions pushed\n * to this array will be called on each tick.\n */\nexport function createTimer(cb) {\n  return (dispatch) => {\n    let last = Date.now();\n    let syncing = false;\n\n    function finishedSync() {\n      syncing = false;\n      cb();\n    }\n\n    const intv = setInterval(() => {\n      // Resync if one 1000ms interval skipped over more than 5s of time.\n      // This most likely means the user's computer's time changed.\n      const now = Date.now();\n      if (Math.abs(last - now) > 5000) {\n        syncing = true;\n        dispatch(sync()).then(finishedSync, finishedSync);\n      } else if (!syncing) {\n        // If we're currently syncing we don't update timed elements for\n        // a while, to prevent weird back and forth jumps.\n        cb();\n      }\n      last = now;\n    }, 1000);\n\n    dispatch({\n      type: SET_TIMER,\n      payload: intv,\n    });\n  };\n}\n\nexport function stopTimer() {\n  return (dispatch, getState) => {\n    const timer = timerSelector(getState());\n    clearInterval(timer);\n    dispatch({\n      type: SET_TIMER,\n      payload: null,\n    });\n  };\n}\n"]}