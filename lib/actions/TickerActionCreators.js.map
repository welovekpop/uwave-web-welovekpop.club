{"version":3,"sources":["actions/TickerActionCreators.js"],"names":["syncTimestamps","sync","createTimer","stopTimer","clientTimeBefore","serverTime","clientTimeAfter","Date","now","type","payload","Math","round","before","onComplete","time","dispatch","callbacks","last","syncing","notifyListeners","forEach","cb","finishedSync","intv","setInterval","abs","then","getState","timer","clearInterval"],"mappings":";;;;;QAKgBA,c,GAAAA,c;QAQAC,I,GAAAA,I;QASAC,W,GAAAA,W;QAwCAC,S,GAAAA,S;;AA9DhB;;AAEA;;AACA;;AAEO,SAASH,cAAT,CAAwBI,gBAAxB,EAA0CC,UAA1C,EAAsD;AAC3D,MAAIC,kBAAkBC,KAAKC,GAAL,EAAtB;AACA,SAAO;AACLC,sBADK;AAELC,aAASC,KAAKC,KAAL,CAAW,CAACP,aAAaD,gBAAb,IAAiCC,aAAaC,eAA9C,CAAD,IAAmE,CAA9E;AAFJ,GAAP;AAID;;AAEM,SAASL,IAAT,GAAgB;AACrB,MAAIY,SAASN,KAAKC,GAAL,EAAb;AACA,SAAO,gCAAI,MAAJ,EAAY;AACjBM,gBAAY,SAASA,UAAT,CAAoBN,GAApB,EAAyB;AACnC,aAAOR,eAAea,MAAf,EAAuBL,IAAIO,IAA3B,CAAP;AACD;AAHgB,GAAZ,CAAP;AAKD;;AAEM,SAASb,WAAT,GAAuB;AAC5B,SAAO,UAAUc,QAAV,EAAoB;AACzB,QAAIC,YAAY,EAAhB;AACA,QAAIC,OAAOX,KAAKC,GAAL,EAAX;AACA,QAAIW,UAAU,KAAd;;AAEA,aAASC,eAAT,GAA2B;AACzBH,gBAAUI,OAAV,CAAkB,UAAUC,EAAV,EAAc;AAC9B,eAAOA,IAAP;AACD,OAFD;AAGD;AACD,aAASC,YAAT,GAAwB;AACtBJ,gBAAU,KAAV;AACAC;AACD;;AAED,QAAII,OAAOC,YAAY,YAAY;AACjC;AACA;AACA,UAAIjB,MAAMD,KAAKC,GAAL,EAAV;AACA,UAAIG,KAAKe,GAAL,CAASR,OAAOV,GAAhB,IAAuB,IAA3B,EAAiC;AAC/BW,kBAAU,IAAV;AACAH,iBAASf,MAAT,EAAiB0B,IAAjB,CAAsBJ,YAAtB,EAAoCA,YAApC;AACD,OAHD,MAGO,IAAI,CAACJ,OAAL,EAAc;AACnB;AACA;AACAC;AACD;AACDF,aAAOV,GAAP;AACD,KAbU,EAaR,IAbQ,CAAX;;AAeAQ,aAAS;AACPP,2BADO;AAEPC,eAASc;AAFF,KAAT;;AAKA,WAAOP,SAAP;AACD,GApCD;AAqCD;;AAEM,SAASd,SAAT,GAAqB;AAC1B,SAAO,UAAUa,QAAV,EAAoBY,QAApB,EAA8B;AACnC,QAAIC,QAAQ,kCAAcD,UAAd,CAAZ;AACAE,kBAAcD,KAAd;AACAb,aAAS;AACPP,2BADO;AAEPC,eAAS;AAFF,KAAT;AAID,GAPD;AAQD;AACD","file":"TickerActionCreators.js","sourcesContent":["import { get } from './RequestActionCreators';\n\nimport { SET_TIMER, OFFSET } from '../constants/actionTypes/time';\nimport { timerSelector } from '../selectors/timeSelectors';\n\nexport function syncTimestamps(clientTimeBefore, serverTime) {\n  const clientTimeAfter = Date.now();\n  return {\n    type: OFFSET,\n    payload: Math.round(((serverTime - clientTimeBefore) + (serverTime - clientTimeAfter)) / 2)\n  };\n}\n\nexport function sync() {\n  const before = Date.now();\n  return get('/now', {\n    onComplete: now => syncTimestamps(before, now.time)\n  });\n}\n\nexport function createTimer() {\n  return (dispatch) => {\n    const callbacks = [];\n    let last = Date.now();\n    let syncing = false;\n\n    function notifyListeners() {\n      callbacks.forEach(cb => cb());\n    }\n    function finishedSync() {\n      syncing = false;\n      notifyListeners();\n    }\n\n    const intv = setInterval(() => {\n      // Resync if one 1000ms interval skipped over more than 5s of time.\n      // This most likely means the user's computer's time changed.\n      const now = Date.now();\n      if (Math.abs(last - now) > 5000) {\n        syncing = true;\n        dispatch(sync()).then(finishedSync, finishedSync);\n      } else if (!syncing) {\n        // If we're currently syncing we don't update timed elements for\n        // a while, to prevent weird back and forth jumps.\n        notifyListeners();\n      }\n      last = now;\n    }, 1000);\n\n    dispatch({\n      type: SET_TIMER,\n      payload: intv\n    });\n\n    return callbacks;\n  };\n}\n\nexport function stopTimer() {\n  return (dispatch, getState) => {\n    const timer = timerSelector(getState());\n    clearInterval(timer);\n    dispatch({\n      type: SET_TIMER,\n      payload: null\n    });\n  };\n}\n"]}