{"version":3,"sources":["actions/TickerActionCreators.js"],"names":["get","SET_TIMER","OFFSET","timerSelector","syncTimestamps","clientTimeBefore","serverTime","clientTimeAfter","Date","now","type","payload","Math","round","sync","before","onComplete","time","createTimer","dispatch","callbacks","last","syncing","notifyListeners","forEach","cb","finishedSync","intv","setInterval","abs","then","stopTimer","getState","timer","clearInterval"],"mappings":"AAAA,SAASA,GAAT,QAAoB,yBAApB;;AAEA,SAASC,SAAT,EAAoBC,MAApB,QAAkC,+BAAlC;AACA,SAASC,aAAT,QAA8B,4BAA9B;;AAEA,OAAO,SAASC,cAAT,CAAwBC,gBAAxB,EAA0CC,UAA1C,EAAsD;AAC3D,MAAMC,kBAAkBC,KAAKC,GAAL,EAAxB;AACA,SAAO;AACLC,UAAMR,MADD;AAELS,aAASC,KAAKC,KAAL,CAAW,CAAEP,aAAaD,gBAAd,IAAmCC,aAAaC,eAAhD,CAAD,IAAqE,CAAhF;AAFJ,GAAP;AAID;;AAED,OAAO,SAASO,IAAT,GAAgB;AACrB,MAAMC,SAASP,KAAKC,GAAL,EAAf;AACA,SAAOT,IAAI,MAAJ,EAAY;AACjBgB,gBAAY;AAAA,aAAOZ,eAAeW,MAAf,EAAuBN,IAAIQ,IAA3B,CAAP;AAAA;AADK,GAAZ,CAAP;AAGD;;AAED,OAAO,SAASC,WAAT,GAAuB;AAC5B,SAAO,UAACC,QAAD,EAAc;AACnB,QAAMC,YAAY,EAAlB;AACA,QAAIC,OAAOb,KAAKC,GAAL,EAAX;AACA,QAAIa,UAAU,KAAd;;AAEA,aAASC,eAAT,GAA2B;AACzBH,gBAAUI,OAAV,CAAkB;AAAA,eAAMC,IAAN;AAAA,OAAlB;AACD;AACD,aAASC,YAAT,GAAwB;AACtBJ,gBAAU,KAAV;AACAC;AACD;;AAED,QAAMI,OAAOC,YAAY,YAAM;AAC7B;AACA;AACA,UAAMnB,MAAMD,KAAKC,GAAL,EAAZ;AACA,UAAIG,KAAKiB,GAAL,CAASR,OAAOZ,GAAhB,IAAuB,IAA3B,EAAiC;AAC/Ba,kBAAU,IAAV;AACAH,iBAASL,MAAT,EAAiBgB,IAAjB,CAAsBJ,YAAtB,EAAoCA,YAApC;AACD,OAHD,MAGO,IAAI,CAACJ,OAAL,EAAc;AACnB;AACA;AACAC;AACD;AACDF,aAAOZ,GAAP;AACD,KAbY,EAaV,IAbU,CAAb;;AAeAU,aAAS;AACPT,YAAMT,SADC;AAEPU,eAASgB;AAFF,KAAT;;AAKA,WAAOP,SAAP;AACD,GAlCD;AAmCD;;AAED,OAAO,SAASW,SAAT,GAAqB;AAC1B,SAAO,UAACZ,QAAD,EAAWa,QAAX,EAAwB;AAC7B,QAAMC,QAAQ9B,cAAc6B,UAAd,CAAd;AACAE,kBAAcD,KAAd;AACAd,aAAS;AACPT,YAAMT,SADC;AAEPU,eAAS;AAFF,KAAT;AAID,GAPD;AAQD","file":"TickerActionCreators.js","sourcesContent":["import { get } from './RequestActionCreators';\n\nimport { SET_TIMER, OFFSET } from '../constants/actionTypes/time';\nimport { timerSelector } from '../selectors/timeSelectors';\n\nexport function syncTimestamps(clientTimeBefore, serverTime) {\n  const clientTimeAfter = Date.now();\n  return {\n    type: OFFSET,\n    payload: Math.round(((serverTime - clientTimeBefore) + (serverTime - clientTimeAfter)) / 2)\n  };\n}\n\nexport function sync() {\n  const before = Date.now();\n  return get('/now', {\n    onComplete: now => syncTimestamps(before, now.time)\n  });\n}\n\nexport function createTimer() {\n  return (dispatch) => {\n    const callbacks = [];\n    let last = Date.now();\n    let syncing = false;\n\n    function notifyListeners() {\n      callbacks.forEach(cb => cb());\n    }\n    function finishedSync() {\n      syncing = false;\n      notifyListeners();\n    }\n\n    const intv = setInterval(() => {\n      // Resync if one 1000ms interval skipped over more than 5s of time.\n      // This most likely means the user's computer's time changed.\n      const now = Date.now();\n      if (Math.abs(last - now) > 5000) {\n        syncing = true;\n        dispatch(sync()).then(finishedSync, finishedSync);\n      } else if (!syncing) {\n        // If we're currently syncing we don't update timed elements for\n        // a while, to prevent weird back and forth jumps.\n        notifyListeners();\n      }\n      last = now;\n    }, 1000);\n\n    dispatch({\n      type: SET_TIMER,\n      payload: intv\n    });\n\n    return callbacks;\n  };\n}\n\nexport function stopTimer() {\n  return (dispatch, getState) => {\n    const timer = timerSelector(getState());\n    clearInterval(timer);\n    dispatch({\n      type: SET_TIMER,\n      payload: null\n    });\n  };\n}\n"]}