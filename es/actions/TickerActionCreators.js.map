{"version":3,"sources":["actions/TickerActionCreators.js"],"names":["get","SET_TIMER","OFFSET","timerSelector","syncTimestamps","clientTimeBefore","serverTime","clientTimeAfter","Date","now","type","payload","Math","round","sync","before","onComplete","time","createTimer","cb","dispatch","last","syncing","finishedSync","intv","setInterval","abs","then","stopTimer","getState","timer","clearInterval"],"mappings":"AAAA,SAASA,GAAT,QAAoB,yBAApB;AACA,SAASC,SAAT,EAAoBC,MAApB,QAAkC,0BAAlC;AACA,SAASC,aAAT,QAA8B,4BAA9B;AAEA,OAAO,SAASC,cAAT,CAAwBC,gBAAxB,EAA0CC,UAA1C,EAAsD;AAC3D,MAAMC,kBAAkBC,KAAKC,GAAL,EAAxB;AACA,SAAO;AACLC,UAAMR,MADD;AAELS,aAASC,KAAKC,KAAL,CAAW,CAAEP,aAAaD,gBAAd,IAAmCC,aAAaC,eAAhD,CAAD,IAAqE,CAAhF;AAFJ,GAAP;AAID;AAED,OAAO,SAASO,IAAT,GAAgB;AACrB,MAAMC,SAASP,KAAKC,GAAL,EAAf;AACA,SAAOT,IAAI,MAAJ,EAAY;AACjBgB,gBAAY;AAAA,aAAOZ,eAAeW,MAAf,EAAuBN,IAAIQ,IAA3B,CAAP;AAAA;AADK,GAAZ,CAAP;AAGD;AAED;;;;;;;AAMA,OAAO,SAASC,WAAT,CAAqBC,EAArB,EAAyB;AAC9B,SAAO,UAACC,QAAD,EAAc;AACnB,QAAIC,OAAOb,KAAKC,GAAL,EAAX;AACA,QAAIa,UAAU,KAAd;;AAEA,aAASC,YAAT,GAAwB;AACtBD,gBAAU,KAAV;AACAH;AACD;;AAED,QAAMK,OAAOC,YAAY,YAAM;AAC7B;AACA;AACA,UAAMhB,MAAMD,KAAKC,GAAL,EAAZ;;AACA,UAAIG,KAAKc,GAAL,CAASL,OAAOZ,GAAhB,IAAuB,IAA3B,EAAiC;AAC/Ba,kBAAU,IAAV;AACAF,iBAASN,MAAT,EAAiBa,IAAjB,CAAsBJ,YAAtB,EAAoCA,YAApC;AACD,OAHD,MAGO,IAAI,CAACD,OAAL,EAAc;AACnB;AACA;AACAH;AACD;;AACDE,aAAOZ,GAAP;AACD,KAbY,EAaV,IAbU,CAAb;AAeAW,aAAS;AACPV,YAAMT,SADC;AAEPU,eAASa;AAFF,KAAT;AAID,GA5BD;AA6BD;AAED,OAAO,SAASI,SAAT,GAAqB;AAC1B,SAAO,UAACR,QAAD,EAAWS,QAAX,EAAwB;AAC7B,QAAMC,QAAQ3B,cAAc0B,UAAd,CAAd;AACAE,kBAAcD,KAAd;AACAV,aAAS;AACPV,YAAMT,SADC;AAEPU,eAAS;AAFF,KAAT;AAID,GAPD;AAQD","sourcesContent":["import { get } from './RequestActionCreators';\nimport { SET_TIMER, OFFSET } from '../constants/ActionTypes';\nimport { timerSelector } from '../selectors/timeSelectors';\n\nexport function syncTimestamps(clientTimeBefore, serverTime) {\n  const clientTimeAfter = Date.now();\n  return {\n    type: OFFSET,\n    payload: Math.round(((serverTime - clientTimeBefore) + (serverTime - clientTimeAfter)) / 2),\n  };\n}\n\nexport function sync() {\n  const before = Date.now();\n  return get('/now', {\n    onComplete: now => syncTimestamps(before, now.time),\n  });\n}\n\n/**\n * Create an auto-syncing timer that ticks once each second.\n *\n * When dispatched, the action returns an array. Functions pushed\n * to this array will be called on each tick.\n */\nexport function createTimer(cb) {\n  return (dispatch) => {\n    let last = Date.now();\n    let syncing = false;\n\n    function finishedSync() {\n      syncing = false;\n      cb();\n    }\n\n    const intv = setInterval(() => {\n      // Resync if one 1000ms interval skipped over more than 5s of time.\n      // This most likely means the user's computer's time changed.\n      const now = Date.now();\n      if (Math.abs(last - now) > 5000) {\n        syncing = true;\n        dispatch(sync()).then(finishedSync, finishedSync);\n      } else if (!syncing) {\n        // If we're currently syncing we don't update timed elements for\n        // a while, to prevent weird back and forth jumps.\n        cb();\n      }\n      last = now;\n    }, 1000);\n\n    dispatch({\n      type: SET_TIMER,\n      payload: intv,\n    });\n  };\n}\n\nexport function stopTimer() {\n  return (dispatch, getState) => {\n    const timer = timerSelector(getState());\n    clearInterval(timer);\n    dispatch({\n      type: SET_TIMER,\n      payload: null,\n    });\n  };\n}\n"],"file":"TickerActionCreators.js"}